SQL Join – одна из наиболее часто используемых команд в SQL-синтаксисе. Она используется для поиска информации в базах 
данных по заранее определенным критериям. В частности, Join отвечает за объединение нескольких групп данных в единый 
поток информации. И это действительно необходимо, потому что в 100% случаев контент в реляционных базах данных с 
поддержкой SQL-синтаксиса делится на множество таблиц, фильтровать данные в которых можно с помощью специальных команд 
и запросом информации из общего пула таблиц. SQL Join помогает настроить фильтр поиска в базе данных, опираясь на 
взаимосвязи между различными элементами БД и их отличительные черты (теги, ID, наименования и т.п.).


SQL Inner Join

Этот режим объединения результатов поиска в базах данных SQL включается автоматически. Если вы не укажете намеренно тип 
Join, то сработает именно Inner Join. С помощью него можно указать сразу два критерия (две таблицы) и по ним отсеять 
контент. 

Достаточно прописать SQL-запрос в духе:

SELECT *
FROM table-1
JOIN table-2 ON table-1.parameter=table-2.parameter
WHERE table-1.parameter IS ‘myData’

Фактически мы пытаемся выудить данные из первой таблицы и объединить их с данными из второй таблицы, при этом фильтруя 
только те записи, в которых совпадает значение параметра. В первой таблице оно приравнивается к myData.
На практике это может использоваться на сайте с музыкальными инструментами, например. Можно запрашивать гитары 
конкретного бренда, при этом еще и выбирая дополнительное условие в духе количества струн.

SELECT *
FROM SevenStringGuitars
JOIN Ibanez ON SevenStringGuitar.brandId=Ibanez.brandId

Таким SQL-запросом мы можем отфильтровать все инструменты бренда Ibanez в категории «Гитары» с 7 струнами. 

SQL Self Join 

Запросы Self Join полезны в тех случаях, когда необходимо выполнить фильтрацию контента внутри одной таблицы. Например,
у вас есть список товаров в базе данных. У каждого из них указан свой бренд, но есть и те, что поставляются одним
производителем. Self Join можно использовать для объединения двух стеков информации из одной таблицы. 

Например, можно запросить информацию о наименовании товара и параллельно обратиться к базе с названием бренда.
Результатом работы функции станет появление нового списка товаров, соответствующего критериям.

SQL-команда в этом случае может выглядеть следующим образом:

SELECT *
FROM products JOIN products ON table.product=table.brand

Такой сценарий полезен практически в любом виде баз данных, так как в одной таблице нередко может храниться информация
о товарах или контенте, имеющим большое количество общих параметров. 

SQL Cross Join
Самый специфичный вариант фильтрации данных. Он подразумевает сбор сразу всех комбинаций элементов из нескольких таблиц,
без обращения к какой-либо дополнительной информации (не требуется указывать id или любую другую строку в таблице).

Стандартный SQL-запрос с Cross Join может выглядеть следующим образом:

SELECT *
FROM table-1
CROSS JOIN table-2

Этого достаточно, чтобы создать новый список элементов, в котором будут собраны все строки из базы данных, 
отфильтрованные только по выбранным таблицам. Полученный набор данных называют декартовым произведением. Схематично его 
часто изображают как большое количество перекрестий между двумя группами элементов. Такой вид JOIN применяется в 
онлайн-магазинах для вывода всех возможных пар по выбранным характеристикам одежды (цвету и размеру или другим 
параметрам).

SQL Outer Join

Outer Join – это своего рода противоположность Inner Join. Как понятно из названия, Outer Join предоставляет информацию
не только из внутренней части поиска, но и из внешней. То есть программа ищет не только точечные совпадения по выбранным
ранее критериям, а позволяет немного ослабить «хватку» и предоставить более «свободные» результаты поиска, включающие в
себя элементы из таблиц, которые хоть и совпадают с критериями в SQL-запросе, но не полностью.
Когда такой подход может понадобиться? Например, для скрупулезной фильтрации товаров. Если вы готовы покупать продукцию
компании «Шестерочка» и не против, если среди нее окажется молоко, но при этом вы точно не хотите покупать молоко других
производителей, то вам подойдет подобный фильтр. Он позволяет дать одному из критериев поиска что-то в духе привилегий. 

Разновидности Outer Join

Внешние Join-запросы существуют не в единственном виде, а сразу в трех вариациях. Каждый вариант по-своему обрабатывает
информацию и в итоге выдает разные результаты. 

Left
Левое объединение подразумевает как раз выше описанный сценарий. Когда мы берем одну таблицу, подключаем вторую и при 
этом показываем не только точные совпадения, но еще и весь список строк, полученных из левой таблицы, для которых не 
нашлось пары в правой таблице. На практике это может выглядеть так:

SELECT *
FROM table1
LEFT JOIN table2 ON table1.parameter=table2.parameter
Теперь мы объединяем первую и вторую таблицу, доставая информацию как о совпадениях по заданным параметрам, так и по 
контенту без пары в левой таблице. 

При желании, надстраивая подобный фильтр, можно вовсе исключить целую категорию строк:

SELECT * 
FROM table1
LEFT JOIN table2 ON table1.parameter=table2.parameter
WHERE table2.parameter IS NULL
На живом примере фильтрация такого рода может выглядеть так:

SELECT *
FROM Russian
LEFT JOIN Rap ON Russian.genreId=Rap.genreId

Представим, что мы запустили продвинутый поиск на сайте с музыкальными альбомами. Мы хотим послушать что-то на русском 
языке. Причем готовы даже оценить качество отечественного рэпа. При этом в целом мы рэп не любим и не хотим, чтобы он 
попадался на каких-то других языках.

Right
Понятно, что правое объединение будет работать в обратную сторону и покажет элементы из правой таблицы, для которых не 
нашлось пары в левой. 

Получится следующий SQL-запрос:

SELECT *
FROM table1
RIGHT JOIN table2 ON table1.parameter=table2.parameter
Если взять пример из предыдущей главы, то в реальности можно обернуть ситуацию в противоположную сторону. Искать только 
рэп-музыку, исключив все русское, кроме хип-хопа. Получится что-то в духе:

SELECT *
FROM Russian
RIGHT JOIN Rap ON Russian.genreId=Rap.genreId

Full

Это вариант для тех, кто хочет использовать сразу два разных критерия для поиска какого-либо контента. Снова вернемся к 
примеру с музыкальным приложением. Join Full может пригодиться, если вы хотите послушать либо что-то на русском, либо 
любой рэп. Вам не важны какие-либо другие параметры. Вас волнуют исключительно две характеристики. При этом вам не так 
важно, будут ли они пересекаться. То есть вам все равно, будет рэп на русском или же на русском будет какой-то 
агрессивный металл. SQL-запрос с таким Join мог бы выглядеть следующим образом:

SELECT *
FROM table1
FULL OUTER JOIN table2 ON table1.parameter=table2.parameter

Можно исключить из результатов фильтрации все пары. То есть можно выбрать только рэп, но ни в коем случае не русский, 
и русскую музыку, но ни в коем случае не рэп (вполне могу понять такой выбор, кстати говоря). Чтобы это сделать, 
необходимо написать следующий SQL-запрос. 

SELECT *
FROM Russian
FULL OUTER JOIN Rap ON Russian.genreId=Rap.genreId
WHERE Russian.genreId IS NULL OR Rap.genreId IS NULL

Теперь вы увидите в результатах поиска только непарные строки.